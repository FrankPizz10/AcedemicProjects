# AcedemicProjects

The first interface we made was the IModel interface. This interface includes the methods addShape(IShape shape), removeShape(char name), getShapes(), animate(), and textOutput(). These methods allow us to interact with different shapes in our model.
All shapes in this design implement the IShape interface. This allows us to get the x,y position of the shape, the r, g, and b color values of the shape, and the width and height. It also allows us to set the x,y position, set the width and height, and set the r, g, and b color values. This allows us the ability to animate them in the future.
An AShape implements IShape and has a char name and int value for x, y, width, height, red, green, blue, and current time. This allows us to maintain certain invariants such as positive size, color values between 0 - 255, and time strictly increasing. Name is also an invariant.
An animation is a class that has a shape to be animated, and a HashMap that keeps track of the shape's both new and old properties. It has one method get text which produces a string of the current animation with shape name, start and end times, start and end positions, start and end size, and start and end color. 
The class Model implements IModel and allows us to animate shapes. This class contains a HashMap with all the shapes in the model along with all the animations they have been through. The method animate() creates a new animation and resets all the values for the given IShape. This methods keeps all the class invariants for AShape intact. The method textOutput() uses animation.getText for all the shapes and all the animations for each shape in the HashMap.
The View interface is the representation for the different types of view which implement this interface. The textual view returns a string interpretation of the animation. The SVG view returns a string containing an SVG interpretation of the animation in HTML. The third view, the visual view, returns a JFrame animation. 
The VisualView uses a class called Drawing which helps paint the shapes on the JFrame. In this Drawing class we set up an initial time of 0 and start a Timer with a period based on tickrae specified by client. The Timer will run a TimerTask at the end of each period or tick. Our task simply includes repainting and incrementing the time. The paint method uses linear interpolation to get the value of each characteristic of the shape at the given time. We use a method shape.draw which uses dynamic dispatch to properly fill each shape on the screen.
The commands class is used to interpret the different command inputs. It sets up the input and output files, reads the commands from the input file and outputs the expected view. 
For the Assignment 7, we had to rethink how we can play an animation based on KeyFrames. To do this we added a new map to our model. This map contains all the shapes in the model as keys and an ArrayList of KeyFrames as values. A KeyFrame is a class we made that is similar to The animation class we created. The class uses another class called properties so that we can map time values to the characteristics of the shape.

We implemented a new view called EnhancedView which extends view. This view uses a new class called EnhancedDrawing which allows us to override run and paint. The new run method allows us to pause and restart animations by pausing the time value we have or setting it back to zero.
We created a Controller class which acts as a listener for user input from key presses. It contains a map of KeyEvents to IFeatures. An IFeature has only one method run. These methods simply perform the correct task based on user input. 
Side notes: equals() and hashCode() have been rewritten in all IShapes so that they can be differentiated based on name only since this is the only final field in these classes.
